
DISPLAY.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000003b8  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000c2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  000003b8  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000003b8  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  000003e7  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000058  00000000  00000000  000003f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000dfe  00000000  00000000  0000044d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000805  00000000  00000000  0000124b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004e5  00000000  00000000  00001a50  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000078  00000000  00000000  00001f38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000220  00000000  00000000  00001fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000101  00000000  00000000  000021d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  000022d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  00000340  00000340  000003b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000230c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.Keypad_Init 0000004a  000002c4  000002c4  00000338  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.Keypad_Read 00000104  000000d2  000000d2  00000146  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .progmemx.data.key_table 00000010  000000c2  000000c2  00000136  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 18 .text.DisplayInit 00000032  0000030e  0000030e  00000382  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.DisplaySet 0000008e  000001d6  000001d6  0000024a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.main    00000060  00000264  00000264  000002d8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 37 00 	jmp	0x6e	; 0x6e <__ctors_end>
   4:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
   8:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
   c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  10:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  14:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  18:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  1c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  20:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  24:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  28:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  2c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  30:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  34:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  38:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  3c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  40:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  44:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  48:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  4c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  50:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  54:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  58:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  5c:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  60:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>
  64:	0c 94 a0 01 	jmp	0x340	; 0x340 <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 01       	movw	r0, r2
  6c:	80 00       	.word	0x0080	; ????

0000006e <__ctors_end>:
  6e:	11 24       	eor	r1, r1
  70:	1f be       	out	0x3f, r1	; 63
  72:	cf ef       	ldi	r28, 0xFF	; 255
  74:	d8 e0       	ldi	r29, 0x08	; 8
  76:	de bf       	out	0x3e, r29	; 62
  78:	cd bf       	out	0x3d, r28	; 61

0000007a <__do_copy_data>:
  7a:	e8 e6       	ldi	r30, 0x68	; 104
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	40 e0       	ldi	r20, 0x00	; 0
  80:	17 c0       	rjmp	.+46     	; 0xb0 <__do_clear_bss+0x8>
  82:	b5 91       	lpm	r27, Z+
  84:	a5 91       	lpm	r26, Z+
  86:	35 91       	lpm	r19, Z+
  88:	25 91       	lpm	r18, Z+
  8a:	05 91       	lpm	r16, Z+
  8c:	07 fd       	sbrc	r16, 7
  8e:	0c c0       	rjmp	.+24     	; 0xa8 <__do_clear_bss>
  90:	95 91       	lpm	r25, Z+
  92:	85 91       	lpm	r24, Z+
  94:	ef 01       	movw	r28, r30
  96:	f9 2f       	mov	r31, r25
  98:	e8 2f       	mov	r30, r24
  9a:	05 90       	lpm	r0, Z+
  9c:	0d 92       	st	X+, r0
  9e:	a2 17       	cp	r26, r18
  a0:	b3 07       	cpc	r27, r19
  a2:	d9 f7       	brne	.-10     	; 0x9a <__do_copy_data+0x20>
  a4:	fe 01       	movw	r30, r28
  a6:	04 c0       	rjmp	.+8      	; 0xb0 <__do_clear_bss+0x8>

000000a8 <__do_clear_bss>:
  a8:	1d 92       	st	X+, r1
  aa:	a2 17       	cp	r26, r18
  ac:	b3 07       	cpc	r27, r19
  ae:	e1 f7       	brne	.-8      	; 0xa8 <__do_clear_bss>
  b0:	ed 36       	cpi	r30, 0x6D	; 109
  b2:	f4 07       	cpc	r31, r20
  b4:	31 f7       	brne	.-52     	; 0x82 <__do_copy_data+0x8>
  b6:	0e 94 32 01 	call	0x264	; 0x264 <main>
  ba:	0c 94 5f 00 	jmp	0xbe	; 0xbe <_exit>

000000be <_exit>:
  be:	f8 94       	cli

000000c0 <__stop_program>:
  c0:	ff cf       	rjmp	.-2      	; 0xc0 <__stop_program>

Disassembly of section .text:

00000340 <__bad_interrupt>:
 340:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.Keypad_Init:

000002c4 <Keypad_Init>:
  * @brief configura los pines usados
  */

void Keypad_Init(void){
	//configuramos los pines de salida
	OUTPUT_PIN(R1);
 2c4:	8a b1       	in	r24, 0x0a	; 10
 2c6:	84 60       	ori	r24, 0x04	; 4
 2c8:	8a b9       	out	0x0a, r24	; 10
	OUTPUT_PIN(R2);
 2ca:	8a b1       	in	r24, 0x0a	; 10
 2cc:	88 60       	ori	r24, 0x08	; 8
 2ce:	8a b9       	out	0x0a, r24	; 10
	OUTPUT_PIN(R3);
 2d0:	8a b1       	in	r24, 0x0a	; 10
 2d2:	80 61       	ori	r24, 0x10	; 16
 2d4:	8a b9       	out	0x0a, r24	; 10
	OUTPUT_PIN(R4);
 2d6:	8a b1       	in	r24, 0x0a	; 10
 2d8:	80 62       	ori	r24, 0x20	; 32
 2da:	8a b9       	out	0x0a, r24	; 10
	//configuramos los pines como entrada
	INPUT_PIN(C1);
 2dc:	8a b1       	in	r24, 0x0a	; 10
 2de:	8f 7b       	andi	r24, 0xBF	; 191
 2e0:	8a b9       	out	0x0a, r24	; 10
 2e2:	8b b1       	in	r24, 0x0b	; 11
 2e4:	80 64       	ori	r24, 0x40	; 64
 2e6:	8b b9       	out	0x0b, r24	; 11
	INPUT_PIN(C2);
 2e8:	8a b1       	in	r24, 0x0a	; 10
 2ea:	8f 77       	andi	r24, 0x7F	; 127
 2ec:	8a b9       	out	0x0a, r24	; 10
 2ee:	8b b1       	in	r24, 0x0b	; 11
 2f0:	80 68       	ori	r24, 0x80	; 128
 2f2:	8b b9       	out	0x0b, r24	; 11
	INPUT_PIN(C3);
 2f4:	84 b1       	in	r24, 0x04	; 4
 2f6:	8e 7f       	andi	r24, 0xFE	; 254
 2f8:	84 b9       	out	0x04, r24	; 4
 2fa:	85 b1       	in	r24, 0x05	; 5
 2fc:	81 60       	ori	r24, 0x01	; 1
 2fe:	85 b9       	out	0x05, r24	; 5
	INPUT_PIN(C4);
 300:	84 b1       	in	r24, 0x04	; 4
 302:	8d 7f       	andi	r24, 0xFD	; 253
 304:	84 b9       	out	0x04, r24	; 4
 306:	85 b1       	in	r24, 0x05	; 5
 308:	82 60       	ori	r24, 0x02	; 2
 30a:	85 b9       	out	0x05, r24	; 5
 30c:	08 95       	ret

Disassembly of section .text.Keypad_Read:

000000d2 <Keypad_Read>:
  * @brief configura los pines usados
  */

uint8_t Keypad_Read(void){
	uint8_t row;
	int8_t col = 0;
  d2:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t data;
	for(row = 0; row<4; row++){
  d4:	20 e0       	ldi	r18, 0x00	; 0
  d6:	63 c0       	rjmp	.+198    	; 0x19e <Keypad_Read+0xcc>
		R1_SET;
  d8:	8b b1       	in	r24, 0x0b	; 11
  da:	84 60       	ori	r24, 0x04	; 4
  dc:	8b b9       	out	0x0b, r24	; 11
		R2_SET;
  de:	8b b1       	in	r24, 0x0b	; 11
  e0:	88 60       	ori	r24, 0x08	; 8
  e2:	8b b9       	out	0x0b, r24	; 11
		R3_SET;
  e4:	8b b1       	in	r24, 0x0b	; 11
  e6:	80 61       	ori	r24, 0x10	; 16
  e8:	8b b9       	out	0x0b, r24	; 11
		R4_SET;
  ea:	8b b1       	in	r24, 0x0b	; 11
  ec:	80 62       	ori	r24, 0x20	; 32
  ee:	8b b9       	out	0x0b, r24	; 11
		switch(row){
  f0:	21 30       	cpi	r18, 0x01	; 1
  f2:	51 f0       	breq	.+20     	; 0x108 <Keypad_Read+0x36>
  f4:	28 f0       	brcs	.+10     	; 0x100 <Keypad_Read+0x2e>
  f6:	22 30       	cpi	r18, 0x02	; 2
  f8:	59 f0       	breq	.+22     	; 0x110 <Keypad_Read+0x3e>
  fa:	23 30       	cpi	r18, 0x03	; 3
  fc:	69 f0       	breq	.+26     	; 0x118 <Keypad_Read+0x46>
  fe:	0f c0       	rjmp	.+30     	; 0x11e <Keypad_Read+0x4c>
			case 0: R1_RESET; break;
 100:	8b b1       	in	r24, 0x0b	; 11
 102:	8b 7f       	andi	r24, 0xFB	; 251
 104:	8b b9       	out	0x0b, r24	; 11
 106:	0b c0       	rjmp	.+22     	; 0x11e <Keypad_Read+0x4c>
			case 1: R2_RESET; break;
 108:	8b b1       	in	r24, 0x0b	; 11
 10a:	87 7f       	andi	r24, 0xF7	; 247
 10c:	8b b9       	out	0x0b, r24	; 11
 10e:	07 c0       	rjmp	.+14     	; 0x11e <Keypad_Read+0x4c>
			case 2: R3_RESET; break;
 110:	8b b1       	in	r24, 0x0b	; 11
 112:	8f 7e       	andi	r24, 0xEF	; 239
 114:	8b b9       	out	0x0b, r24	; 11
 116:	03 c0       	rjmp	.+6      	; 0x11e <Keypad_Read+0x4c>
			case 3: R4_RESET; break;
 118:	8b b1       	in	r24, 0x0b	; 11
 11a:	8f 7d       	andi	r24, 0xDF	; 223
 11c:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 11e:	8f ec       	ldi	r24, 0xCF	; 207
 120:	97 e0       	ldi	r25, 0x07	; 7
 122:	01 97       	sbiw	r24, 0x01	; 1
 124:	f1 f7       	brne	.-4      	; 0x122 <Keypad_Read+0x50>
 126:	00 c0       	rjmp	.+0      	; 0x128 <Keypad_Read+0x56>
 128:	00 00       	nop
		}
		_delay_us(500);
		data = (uint8_t)(C4_BIT<<3 | C3_BIT<<2 | C2_BIT<<1 | C1_BIT<<0);
 12a:	83 b1       	in	r24, 0x03	; 3
 12c:	81 fb       	bst	r24, 1
 12e:	66 27       	eor	r22, r22
 130:	60 f9       	bld	r22, 0
 132:	70 e0       	ldi	r23, 0x00	; 0
 134:	db 01       	movw	r26, r22
 136:	aa 0f       	add	r26, r26
 138:	bb 1f       	adc	r27, r27
 13a:	aa 0f       	add	r26, r26
 13c:	bb 1f       	adc	r27, r27
 13e:	aa 0f       	add	r26, r26
 140:	bb 1f       	adc	r27, r27
 142:	83 b1       	in	r24, 0x03	; 3
 144:	e8 2f       	mov	r30, r24
 146:	e1 70       	andi	r30, 0x01	; 1
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	af 01       	movw	r20, r30
 14c:	44 0f       	add	r20, r20
 14e:	55 1f       	adc	r21, r21
 150:	44 0f       	add	r20, r20
 152:	55 1f       	adc	r21, r21
 154:	99 b1       	in	r25, 0x09	; 9
 156:	99 1f       	adc	r25, r25
 158:	99 27       	eor	r25, r25
 15a:	99 1f       	adc	r25, r25
 15c:	89 2f       	mov	r24, r25
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	88 0f       	add	r24, r24
 162:	99 1f       	adc	r25, r25
 164:	99 b1       	in	r25, 0x09	; 9
 166:	4a 2b       	or	r20, r26
 168:	84 2b       	or	r24, r20
 16a:	96 fb       	bst	r25, 6
 16c:	99 27       	eor	r25, r25
 16e:	90 f9       	bld	r25, 0
 170:	89 2b       	or	r24, r25
		col = KEYPAD_EMPTY;
		switch(data){
 172:	8b 30       	cpi	r24, 0x0B	; 11
 174:	61 f0       	breq	.+24     	; 0x18e <Keypad_Read+0xbc>
 176:	1c f4       	brge	.+6      	; 0x17e <Keypad_Read+0xac>
 178:	87 30       	cpi	r24, 0x07	; 7
 17a:	59 f0       	breq	.+22     	; 0x192 <Keypad_Read+0xc0>
 17c:	04 c0       	rjmp	.+8      	; 0x186 <Keypad_Read+0xb4>
 17e:	8d 30       	cpi	r24, 0x0D	; 13
 180:	21 f0       	breq	.+8      	; 0x18a <Keypad_Read+0xb8>
 182:	8e 30       	cpi	r24, 0x0E	; 14
 184:	41 f0       	breq	.+16     	; 0x196 <Keypad_Read+0xc4>
			case 2: R3_RESET; break;
			case 3: R4_RESET; break;
		}
		_delay_us(500);
		data = (uint8_t)(C4_BIT<<3 | C3_BIT<<2 | C2_BIT<<1 | C1_BIT<<0);
		col = KEYPAD_EMPTY;
 186:	3f ef       	ldi	r19, 0xFF	; 255
 188:	07 c0       	rjmp	.+14     	; 0x198 <Keypad_Read+0xc6>
		switch(data){
			case 0xE: col = 0; break;
			case 0xD: col = 1; break;
 18a:	31 e0       	ldi	r19, 0x01	; 1
 18c:	05 c0       	rjmp	.+10     	; 0x198 <Keypad_Read+0xc6>
			case 0xB: col = 2; break;
 18e:	32 e0       	ldi	r19, 0x02	; 2
 190:	03 c0       	rjmp	.+6      	; 0x198 <Keypad_Read+0xc6>
			case 0x7: col = 3; break;
 192:	33 e0       	ldi	r19, 0x03	; 3
 194:	01 c0       	rjmp	.+2      	; 0x198 <Keypad_Read+0xc6>
		}
		_delay_us(500);
		data = (uint8_t)(C4_BIT<<3 | C3_BIT<<2 | C2_BIT<<1 | C1_BIT<<0);
		col = KEYPAD_EMPTY;
		switch(data){
			case 0xE: col = 0; break;
 196:	30 e0       	ldi	r19, 0x00	; 0
			case 0xD: col = 1; break;
			case 0xB: col = 2; break;
			case 0x7: col = 3; break;
		}
		if(col != KEYPAD_EMPTY)
 198:	3f 3f       	cpi	r19, 0xFF	; 255
 19a:	21 f4       	brne	.+8      	; 0x1a4 <Keypad_Read+0xd2>

uint8_t Keypad_Read(void){
	uint8_t row;
	int8_t col = 0;
	uint8_t data;
	for(row = 0; row<4; row++){
 19c:	2f 5f       	subi	r18, 0xFF	; 255
 19e:	24 30       	cpi	r18, 0x04	; 4
 1a0:	08 f4       	brcc	.+2      	; 0x1a4 <Keypad_Read+0xd2>
 1a2:	9a cf       	rjmp	.-204    	; 0xd8 <Keypad_Read+0x6>
			case 0x7: col = 3; break;
		}
		if(col != KEYPAD_EMPTY)
		break;      //salida del for
	}
	if(col == KEYPAD_EMPTY)
 1a4:	3f 3f       	cpi	r19, 0xFF	; 255
 1a6:	a9 f0       	breq	.+42     	; 0x1d2 <Keypad_Read+0x100>
	return KEYPAD_EMPTY;
	else
	return(key_table[row][col]);
 1a8:	82 2f       	mov	r24, r18
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	88 0f       	add	r24, r24
 1ae:	99 1f       	adc	r25, r25
 1b0:	88 0f       	add	r24, r24
 1b2:	99 1f       	adc	r25, r25
 1b4:	83 0f       	add	r24, r19
 1b6:	91 1d       	adc	r25, r1
 1b8:	37 fd       	sbrc	r19, 7
 1ba:	9a 95       	dec	r25
 1bc:	09 2e       	mov	r0, r25
 1be:	00 0c       	add	r0, r0
 1c0:	aa 0b       	sbc	r26, r26
 1c2:	8e 53       	subi	r24, 0x3E	; 62
 1c4:	9f 4f       	sbci	r25, 0xFF	; 255
 1c6:	af 4f       	sbci	r26, 0xFF	; 255
 1c8:	fc 01       	movw	r30, r24
 1ca:	84 91       	lpm	r24, Z
 1cc:	a7 fd       	sbrc	r26, 7
 1ce:	80 81       	ld	r24, Z
 1d0:	08 95       	ret
		}
		if(col != KEYPAD_EMPTY)
		break;      //salida del for
	}
	if(col == KEYPAD_EMPTY)
	return KEYPAD_EMPTY;
 1d2:	8f ef       	ldi	r24, 0xFF	; 255
	else
	return(key_table[row][col]);
 1d4:	08 95       	ret

Disassembly of section .text.DisplayInit:

0000030e <DisplayInit>:
		
    }
}

void DisplayInit(void){
	OUTPUT_PIN(AD);
 30e:	84 b1       	in	r24, 0x04	; 4
 310:	84 60       	ori	r24, 0x04	; 4
 312:	84 b9       	out	0x04, r24	; 4
	OUTPUT_PIN(BD);
 314:	84 b1       	in	r24, 0x04	; 4
 316:	88 60       	ori	r24, 0x08	; 8
 318:	84 b9       	out	0x04, r24	; 4
	OUTPUT_PIN(CD);
 31a:	84 b1       	in	r24, 0x04	; 4
 31c:	80 61       	ori	r24, 0x10	; 16
 31e:	84 b9       	out	0x04, r24	; 4
	OUTPUT_PIN(DD);
 320:	84 b1       	in	r24, 0x04	; 4
 322:	80 62       	ori	r24, 0x20	; 32
 324:	84 b9       	out	0x04, r24	; 4
	OUTPUT_PIN(EN1);
 326:	87 b1       	in	r24, 0x07	; 7
 328:	81 60       	ori	r24, 0x01	; 1
 32a:	87 b9       	out	0x07, r24	; 7
	OUTPUT_PIN(EN2);
 32c:	87 b1       	in	r24, 0x07	; 7
 32e:	82 60       	ori	r24, 0x02	; 2
 330:	87 b9       	out	0x07, r24	; 7
	OUTPUT_PIN(EN3);
 332:	87 b1       	in	r24, 0x07	; 7
 334:	84 60       	ori	r24, 0x04	; 4
 336:	87 b9       	out	0x07, r24	; 7
	OUTPUT_PIN(EN4);
 338:	87 b1       	in	r24, 0x07	; 7
 33a:	88 60       	ori	r24, 0x08	; 8
 33c:	87 b9       	out	0x07, r24	; 7
 33e:	08 95       	ret

Disassembly of section .text.DisplaySet:

000001d6 <DisplaySet>:
}

void DisplaySet(uint8_t num, NumDisplay display){
	PIN_RESET(AD);
 1d6:	95 b1       	in	r25, 0x05	; 5
 1d8:	9b 7f       	andi	r25, 0xFB	; 251
 1da:	95 b9       	out	0x05, r25	; 5
	PIN_RESET(BD);
 1dc:	95 b1       	in	r25, 0x05	; 5
 1de:	97 7f       	andi	r25, 0xF7	; 247
 1e0:	95 b9       	out	0x05, r25	; 5
	PIN_RESET(CD);
 1e2:	95 b1       	in	r25, 0x05	; 5
 1e4:	9f 7e       	andi	r25, 0xEF	; 239
 1e6:	95 b9       	out	0x05, r25	; 5
	PIN_RESET(DD);
 1e8:	95 b1       	in	r25, 0x05	; 5
 1ea:	9f 7d       	andi	r25, 0xDF	; 223
 1ec:	95 b9       	out	0x05, r25	; 5
	PIN_RESET(EN1);
 1ee:	98 b1       	in	r25, 0x08	; 8
 1f0:	9e 7f       	andi	r25, 0xFE	; 254
 1f2:	98 b9       	out	0x08, r25	; 8
	PIN_RESET(EN2);
 1f4:	98 b1       	in	r25, 0x08	; 8
 1f6:	9d 7f       	andi	r25, 0xFD	; 253
 1f8:	98 b9       	out	0x08, r25	; 8
	PIN_RESET(EN3);
 1fa:	98 b1       	in	r25, 0x08	; 8
 1fc:	9b 7f       	andi	r25, 0xFB	; 251
 1fe:	98 b9       	out	0x08, r25	; 8
	PIN_RESET(EN4);
 200:	98 b1       	in	r25, 0x08	; 8
 202:	97 7f       	andi	r25, 0xF7	; 247
 204:	98 b9       	out	0x08, r25	; 8
	//ESTABLECER EL VALOR
	if(num & 0x1)
 206:	80 ff       	sbrs	r24, 0
 208:	03 c0       	rjmp	.+6      	; 0x210 <DisplaySet+0x3a>
		PIN_SET(AD);
 20a:	95 b1       	in	r25, 0x05	; 5
 20c:	94 60       	ori	r25, 0x04	; 4
 20e:	95 b9       	out	0x05, r25	; 5
	if(num & 0x2)
 210:	81 ff       	sbrs	r24, 1
 212:	03 c0       	rjmp	.+6      	; 0x21a <DisplaySet+0x44>
		PIN_SET(BD);
 214:	95 b1       	in	r25, 0x05	; 5
 216:	98 60       	ori	r25, 0x08	; 8
 218:	95 b9       	out	0x05, r25	; 5
	if(num & 0x4)
 21a:	82 ff       	sbrs	r24, 2
 21c:	03 c0       	rjmp	.+6      	; 0x224 <DisplaySet+0x4e>
		PIN_SET(CD);
 21e:	95 b1       	in	r25, 0x05	; 5
 220:	90 61       	ori	r25, 0x10	; 16
 222:	95 b9       	out	0x05, r25	; 5
	if(num & 0x8)
 224:	83 ff       	sbrs	r24, 3
 226:	03 c0       	rjmp	.+6      	; 0x22e <DisplaySet+0x58>
		PIN_SET(DD);
 228:	85 b1       	in	r24, 0x05	; 5
 22a:	80 62       	ori	r24, 0x20	; 32
 22c:	85 b9       	out	0x05, r24	; 5
	//ELEJIMOS EN QUE DISPLAY MOSTRAR
	switch(display){
 22e:	62 30       	cpi	r22, 0x02	; 2
 230:	69 f0       	breq	.+26     	; 0x24c <DisplaySet+0x76>
 232:	18 f4       	brcc	.+6      	; 0x23a <DisplaySet+0x64>
 234:	61 30       	cpi	r22, 0x01	; 1
 236:	31 f0       	breq	.+12     	; 0x244 <DisplaySet+0x6e>
 238:	08 95       	ret
 23a:	63 30       	cpi	r22, 0x03	; 3
 23c:	59 f0       	breq	.+22     	; 0x254 <DisplaySet+0x7e>
 23e:	64 30       	cpi	r22, 0x04	; 4
 240:	69 f0       	breq	.+26     	; 0x25c <DisplaySet+0x86>
 242:	08 95       	ret
		case 1: PIN_SET(EN1); break;
 244:	88 b1       	in	r24, 0x08	; 8
 246:	81 60       	ori	r24, 0x01	; 1
 248:	88 b9       	out	0x08, r24	; 8
 24a:	08 95       	ret
		case 2: PIN_SET(EN2); break;
 24c:	88 b1       	in	r24, 0x08	; 8
 24e:	82 60       	ori	r24, 0x02	; 2
 250:	88 b9       	out	0x08, r24	; 8
 252:	08 95       	ret
		case 3: PIN_SET(EN3); break;
 254:	88 b1       	in	r24, 0x08	; 8
 256:	84 60       	ori	r24, 0x04	; 4
 258:	88 b9       	out	0x08, r24	; 8
 25a:	08 95       	ret
		case 4: PIN_SET(EN4); break;
 25c:	88 b1       	in	r24, 0x08	; 8
 25e:	88 60       	ori	r24, 0x08	; 8
 260:	88 b9       	out	0x08, r24	; 8
 262:	08 95       	ret

Disassembly of section .text.main:

00000264 <main>:
void DisplayInit(void);
void DisplaySet(uint8_t num, NumDisplay display);

int main(void)
{
	Keypad_Init();
 264:	0e 94 62 01 	call	0x2c4	; 0x2c4 <Keypad_Init>
	DisplayInit();
 268:	0e 94 87 01 	call	0x30e	; 0x30e <DisplayInit>
	
    while(1)
    {
        //TODO:: Please write your application code 
		data = Keypad_Read();
 26c:	0e 94 69 00 	call	0xd2	; 0xd2 <Keypad_Read>
 270:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
		if(data != KEYPAD_EMPTY){
			if(data == '1')
 274:	81 33       	cpi	r24, 0x31	; 49
 276:	21 f4       	brne	.+8      	; 0x280 <main+0x1c>
				DisplaySet(1,DISPLAY1);
 278:	61 e0       	ldi	r22, 0x01	; 1
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <DisplaySet>
			if(data == '2')
 280:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 284:	82 33       	cpi	r24, 0x32	; 50
 286:	21 f4       	brne	.+8      	; 0x290 <main+0x2c>
				DisplaySet(2,DISPLAY2);
 288:	62 e0       	ldi	r22, 0x02	; 2
 28a:	82 e0       	ldi	r24, 0x02	; 2
 28c:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <DisplaySet>
			if(data == '3')
 290:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 294:	83 33       	cpi	r24, 0x33	; 51
 296:	21 f4       	brne	.+8      	; 0x2a0 <main+0x3c>
				DisplaySet(3,DISPLAY3);
 298:	63 e0       	ldi	r22, 0x03	; 3
 29a:	83 e0       	ldi	r24, 0x03	; 3
 29c:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <DisplaySet>
			if(data == '4')
 2a0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 2a4:	84 33       	cpi	r24, 0x34	; 52
 2a6:	21 f4       	brne	.+8      	; 0x2b0 <main+0x4c>
				DisplaySet(4,DISPLAY4);
 2a8:	64 e0       	ldi	r22, 0x04	; 4
 2aa:	84 e0       	ldi	r24, 0x04	; 4
 2ac:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <DisplaySet>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2b0:	2f ef       	ldi	r18, 0xFF	; 255
 2b2:	80 e7       	ldi	r24, 0x70	; 112
 2b4:	92 e0       	ldi	r25, 0x02	; 2
 2b6:	21 50       	subi	r18, 0x01	; 1
 2b8:	80 40       	sbci	r24, 0x00	; 0
 2ba:	90 40       	sbci	r25, 0x00	; 0
 2bc:	e1 f7       	brne	.-8      	; 0x2b6 <main+0x52>
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <main+0x5c>
 2c0:	00 00       	nop
 2c2:	d4 cf       	rjmp	.-88     	; 0x26c <main+0x8>
